name: PR Label Manager
on:
  workflow_dispatch:      # Allow manual trigger
  schedule:
    - cron: '0 * * * *'  # Run every hou
  # pull_request_review:    # Run when reviews are submitted
  # pull_request:          # Run when PRs are opened/updated
  #   types: [opened, reopened, ready_for_review]

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  manage-labels:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v6

      - name: Update PR Labels
        uses: actions/github-script@v8
        with:
          script: |
            // Configuration
            const fs = require('fs');
            const path = require('path');
            const MAINTAINERS_LIST = fs
              .readFileSync(path.join(process.cwd(), 'MAINTAINERS'), 'utf8')
              .split('\n')
              .map((name) => name.trim())
              .filter(Boolean);

            const LABELS = {
              CHANGES: 'waiting-for-changes',
              REVIEW: 'waiting-for-review',
              MERGE: 'waiting-for-merge'
            };

            // Get all open PRs
            const prs = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open'
            });

            for (const pr of prs.data) {
              // Skip draft PRs and WIP PRs
              if (pr.draft || pr.title.toLowerCase().includes('wip')) {
                continue;
              }

              // Get all reviews for this PR (with pagination)
              const reviews = await github.paginate(
                github.rest.pulls.listReviews,
                {
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: pr.number,
                  per_page: 100
                }
              );

              // Track the latest decision per reviewer.
              // A later COMMENTED review should not override CHANGES_REQUESTED/APPROVED.
              const latestDecisionByReviewer = new Map();
              for (const review of reviews) {
                const reviewer = review.user.login;

                if (review.state === 'CHANGES_REQUESTED' || review.state === 'APPROVED') {
                  latestDecisionByReviewer.set(reviewer, {
                    state: review.state,
                    commitId: review.commit_id
                  });
                } else if (review.state === 'DISMISSED') {
                  latestDecisionByReviewer.delete(reviewer);
                }
              }

              // Determine appropriate label
              let newLabel = LABELS.REVIEW;  // default

              for (const [reviewer, decision] of latestDecisionByReviewer) {
                if (MAINTAINERS_LIST.includes(reviewer)) {
                  const state = decision.state;

                  // A review decision on an older commit is stale once head moves.
                  const staleDecision =
                    decision.commitId && decision.commitId !== pr.head.sha;
                  if (staleDecision) {
                    continue;
                  }

                  if (state === 'CHANGES_REQUESTED') {
                    newLabel = LABELS.CHANGES;
                    break;
                  } else if (state === 'APPROVED') {
                    newLabel = LABELS.MERGE;
                    // Don't break here - keep checking in case there's a newer "changes requested"
                  }
                }
              }

              // Remove all managed labels except the new one
              const allLabels = Object.values(LABELS);
              for (const label of pr.labels) {
                if (allLabels.includes(label.name) && label.name !== newLabel) {
                  await github.rest.issues.removeLabel({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: pr.number,
                    name: label.name
                  });
                }
              }

              // Add new label if not present
              if (!pr.labels.some(label => label.name === newLabel)) {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: pr.number,
                  labels: [newLabel]
                });
              }

              console.log(`PR #${pr.number}: Applied label ${newLabel}`);
            }
